== Shards

Ruby に RubyGems があるように、Crystal にも Shards というパケージ管理の仕組みが存在しています。バージョン `0.8.0` 以降の Crystal コンパイラは、Shards を標準のパッケージマネージャとして採用しています。ですので、Crystal を利用する環境が整っていれば、Shards を利用するための特別な準備は必要ありません。

Shards における個々のパッケージを shard （シャード）と呼びます。これは鉱物などの「欠片」や「破片」といった意味の単語です。Ruby や Python といった先行する言語と比べると充分とは言えないかもしれませんが、それでも GitHub などを利用して 2000 を超える shard が公開されています。

RubyGems と Shards の大きな違いは、パッケージのインストール先です。RubyGems は基本的にグローバルな Ruby の実行環境に対してパッケージをインストールする仕組みであり、それをプロジェクト単位で個別管理するための別途 Bundler が登場しました。一方、Shards では導入パッケージをプロジェクオ単位で管理することが前提となっています。その結果、プロジェクト間でパッケージバージョンのコンフリクトが発生しにくい仕組みになっています。

また、他言語のパッケージ管理手法と異なり、Shards には集中管理された公式のリポジトリが存在しません。ほんとどの shard は、git リポジトリとして（多くの場合 GitHub 上で）公開されています。このことは、shard を公開することへのハードルを大きく下げてくれていますが、一方で公開されている shard のクォリティ確保や、検索性の面では足かせとなっています。

ただし、この原稿を執筆している2018年3月時点で Crystal がまだバージョン `1.0` に至っていないように、Shards の開発もまだ継続しています。現時点で課題となっている点も、今後改善されることを期待しましょう。

この章では、shard の使い方と作り方、および shard 作成において使用することになる spec テストの方法について簡単に説明します。

=== shard を使う

まずは便利な shard を自分のプログラムから利用するための手順を見てみましょう。

==== プロジェクトの機能と名前を決める

前述の通り、Shards では導入パッケージの管理をプロジェクト単位で行います。そのため、まずはプロジェクトで実現する機能とプロジェクトの名前を決める必要があります。

実用的かどうかはさておき、今回は、パラメータとしてページタイトルと本文を受け取って最低限の HTML ソースを出力する、だけのシンプルなコマンドラインツールを例として考えてみましょう。

次にプロジェクトの名前です。shard として公開する場合にはいくつか名前にルール（後述）もありますが、そうでない場合にはそこまで深く考える必要はありません。ということで、今回はシンプル（simple）な HTML を返すアプリですので simple_html というプロジェクト名にすることにします。

.sinple_html コマンド利用イメージ

----
$ simple_html "Page Title" "Page body."
<html><head><title>Page Title</title></head><body><h1>Page Title</h1><p>Page body.</p></body></html>
----

==== プロジェクトひな型を作る

`crystal` コマンドにはソースコードのコンパイル以外にもいくつか便利な機能が実装されており、その中の1つにプロジェクトひな型の生成機能（`crystal init` コマンド）があります。

`crystal init` コマンドを実行する際には、プロジェクトの種類（`app` もしくは `lib`）とプロジェクト名を指定します。したがって、`simple_html` をアプリケーションとして実装する場合のひな形生成コマンドは `crystal init app simple_html` になります。このコマンドを実行するとカレントディレクトリの直下にプロジェクト名と同じ名前の simple_html ディレクトリができ、その中に各種ひな型が自動生成されます。

.simple_html アプリケーション用プロジェクトのひな形生成コマンド

----
$ crystal init app simple_html
----

.プロジェクトひな形として生成されるファイル/ディレクトリ

`.git/`（ディレクトリ）:: このプロジェクト用の初期化済み git リポジトリ。

`.gitignore`:: git 管理除外ファイルの指定用。

`.editorconfig`:: 文字コードや改行コード、インデントなどの設定を異なるエディタ間で共通利用するための設定ファイル。詳細を知りたければ EditorConfig で検索。

`LICENSE`:: このプロジェクトのライセンスを明示するためのテキストファイル。自分で使うだけのアプリケーションなら気にする必要はない。標準では MIT ライセンス前提の内容になっているので、必要に応じて適宜変更する。

`README.md`:: Markdown フォーマットで書かれたこのプロジェクトの README ファイル。GitHub などを通じて公開する予定ならちゃんと書いた方が良い。

`.travis.yml`:: Travis CI を使用してテストやビルドを自動化するための設定ファイル。使いこなせば強力なツール。ただ、最初のうちはあまり気にしなくても良い。

`shard.yml`:: プロジェクトに関連したメタデータ（名前やバージョン、作者など）やプロジェクトが利用する shard などの情報を記述するための設定ファイル。

`src/`（ディレクトリ）:: プログラムのソースディレクトリ。ソースコードはすべてこの配下に置く。

`src/[プロジェクト名].cr`:: プロジェクトのメインソースコード。プログラムのエントリポイント。

`src/[プロジェクト名]/`（ディレクトリ）:: ソースコードを分割する場合、`src/[プロジェクト名].cr` 以外のファイルはここへ置く。

`src/[プロジェクト名]/version.cr`:: プログラム中でプロジェクトバージョンを確認するための定数を定義しているだけのファイル。通常は `src/[プロジェクト名].cr` から `require` される。バージョンを上げたら修正。

`spec/`（ディレクトリ）:: spec テスト用ディレクトリ。テスト関連のファイルはここへ置く。

`spec/spec_helper.cr`:: spec テスト関連ファイルその1。あまり触らない方。

`spec/[プロジェクト名]_spec.cr`:: spec テスト関連ファイルその2（spec ファイル）。実際のテストケースを記述する方。

==== shard を探す

`simple_html` を実装するにあたって HTML をすべて手打ちで書いても良いのですが、いささか面倒臭いので HTML ソースを出力するのに便利な shard を探してみることにします。

Shards には公式リポジトリがなく、公式には shard の検索機能が提供されていません。そのため、標準ライブラリで提供されていない機能を使いたい場合に、その機能を提供する shard が存在かどうかを調べるのが最初のハードルになります。

今のところ、この問題を解決する決定打は出てきていませんが、以下の2サイトは shard を探す助けになってくれるはずです。

====
link:https://github.com/veelenga/awesome-crystal[Awesome Crystal]:: 一定の条件を満たした自薦他薦の shard をカテゴリ分類してリスト化。リストの更新も人の手で管理されているため、限定的ではあるもののある程度の基準をクリアした shard がみつかる。

link:http://crystalshards.xyz/[CrystalShards.xyz]:: GitHub で公開されている shard のキーワード検索機能を提供。GitHub で公開されている shard を自動的に収集しているため玉石混淆ではあるものの、Awesome Crytstal より網羅的にマイナな shard もみつけられる。
====

Awesome Crystal 内を「 html 」で検索してみると、HTML 構築専用の構文を提供してくれる link:https://github.com/crystal-lang/html_builder[html_builder] という shard が見つかりました。早速これを使ってみることにしましょう。

==== 使用する shard を指定する

プロジェクトディレクトリ内にある shard.yaml ファイルは、shard 関係の設定を記述するためのファイルです。

アプリケーションとして初期化された shard.yaml は概ね以下のような内容になっています。また、.gitconfig などで git 用のユーザ名やメールアドレスが設定されていれば、それらが `authors` 属性へ自動挿入されます。

.ひな形生成時の shard.yml

[source, yaml]
----
include::projects/simple_html/shard.yml[lines=1..13]
----

ここへ `html_builder` を指定するための設定を追加しましょう。ほとんどの場合 shard の README には、その shard を使用するために shard.yaml へ追加する内容が紹介されていますので、そちらが参考になります。例えば、`html_builder` の README には以下のように記述されています。

image::05-shards/html_builder_installation.png[]

指定された内容を追加した shard.yaml はこのようになりました。

.依存ライブラリの設定追加後

[source, yaml]
----
include::projects/simple_html/shard.yml[]
----

[suppress='InvalidSymbol']
===== 使いたい shard のバージョン指定するには

`shard.yml` 内で使用する shard のバージョンを指定することもできます。例えば、2018年2月時点の `html_builder` はバージョン `0.2.2` が最新です。そのため、バージョン指定をせず shard をインストールすした上の例では、最新のバージョン `0.2.2` がインストールされました。しかし、`shard.yml` での記述を以下のようにすることで、以前のバージョン `0.2.1` を使用可能です。

.バージョン指定をした shard 設定

[source, yaml]
----
dependencies:
  html_builder:
    github: crystal-lang/html_builder
    version: 0.2.1
----

ここで使用する `version` には、バージョンを直接記述るす以外に、バージョンと `>` `<` `>=` `\<=` `~>` 演算子を組み合わせて使用することもできます。

====
例:: `>= 0.2.0` でバージョン0.2.0以上。
====

これら演算子のうち、`>` `<` `>=` `\<=` あたりは直感的に理解しやすいのですが、`~>` は以下のようにやや特殊な挙動をします。

====
- `~> 2.0.3` は、 `>= 2.0.3` かつ `< 2.1` と同じ。
- `~> 2.1` は、 `>= 2.1` かつ `< 3.0` と同じ。
====

===== GitHub 以外で公開されている shard

`html_builder` は GitHub で公開されている shard でしたが、Shards は GitHub だけでなく、以下の公開方式に対応しています。

.shard の取得先

[source, yaml]
----
# ファイルパス
path: ../path/to/shard
# git
git: git://git.example.org/repository.git
# GitHub
github: user/repository
# bitbucket
bitbucket: user/repository
# gitlab
gitlab: user/repository
----

==== shard をインストールする

shard.yaml に指定した shard をプロジェクト環境にインストールするコマンドは `crystal deps` です。プロジェクトディレクトリの直下でこのコマンドを実行すると、プロジェクトディレクトリの下に lib ディレクトリが作られ、その中に必要なファイル一式が展開されます。

.shard のインストール

----
$ crystal deps
Fetching https://github.com/crystal-lang/html_builder.git
Installing html_builder (0.2.2)
----

これだけで、shard のインストールは完了です。

==== ソースコード内で shard を使う

ひな型生成直後のソースコード `src/simple_html.cr` には、プロジェクト名 `simple_html` をキャメルケースに変換した `SimpleHtml` モジュールが定義されています。この `SimpleHtml` モジュールはこのプロジェクトの名前空間として使用するものです。ですので、特に理由がない限りプロジェクト固有の機能実装は `SimpleHtml` モジュールか、もしくはその中で定義した型に対して行うことになります。

.ひな形生成時のメインソースコード

[source, crystal]
----
include::projects/simple_html/src/simple_html_org.cr[]
----

なお、shard として公開されている機能をプログラム中で利用するためには `require` 文を使用してその旨を明示する必要があります。大抵の場合 shard の README にはその shard の使用法が記載されており `requrie` 文の書き方もそこで確認できます。例えば、`html_builder` の場合は以下のように記述されています。

image::05-shards/html_builder_usage.png[]

指定された `require` 文に加えていくつかのメソッドを実装し、何はともあれ simple_html のソースコードが完成しました。

.完成した simple_html コマンドのソースコード

[source, crystal]
----
include::projects/simple_html/src/simple_html.cr[]
----

`html_builder` の機能を使用して HTML を構築するのは `SimpleHtml` モジュールの  `.build` メソッドです。ただし、コマンドライン実行時にはコマンドラインパラメータ（`ARGV`）を引数として `.run` メソッドがまず呼び出されます。この `.run` メソッドではコマンドラインパラメータの数をチェックしてその後の挙動を振り分けるためのものです。その結果、コマンドラインパラメータが2つ指定されていれば `.build` の結果を標準出力へ、それ以外の場合は `.usage` が返す利用方法を標準エラーへそれぞれ出力します。

==== 実行してみる

ビルド後に試しに実行してみると `html_builder` の機能を使えていることが確認できました。

.simple_html コマンドのコパイルと実行結果

----
$ crystal build src/simple_html.cr
$ ./simple_html "Page Title" "Page body."
<html><head><title>Page Title</title></head><body><h1>Page Title</h1><p>Page body.</p></body></html>
----

動作に問題がないようであれば、実際に使用する実行ファイルは、最適化フラグ `--release` を付けた状態で再度ビルドしましょう。

.最適化フラグを付けたビルド

----
$ crystal build --release src/simple_html.cr
----

以上がインターネット上で公開されている shard を利用する際のざっくりとした手順になります。

.shard を利用する手順のまとめ

****
1. shard を利用するプロジェクトを作成する（`crystal init` コマンド）

2. `shard.yml` に使用したい shard の記述を追加する

3. shard をプロジェクトディレクトリにインストールする（`crystal deps` コマンド）

4. ソースコードの先頭で shard を `require` する

5. ソースコード内で shard が提供する機能を使用する
****

#### 補足： shard のアップデート

Crystal 本体のバージョンを上げたら shard が動かなくなった場合など、インストール済みの shard をアップデートしなければならい場面に遭遇することがあります。

しかし、shard のインストール時に使用した `crystal deps` コマンドは、すでにインストールされている shard については処理を行いません。そのため、再度同じコマンドを実行してもインストール済み shard がバージョンアップはされません。

こうした場面では、替わりに `crystal deps update` コマンドを使用します。このコマンドは、インストール済みの shard が `shard.yml` で指定したバージョンと異なって入れば再取得してくれます。また、`shard.yml` でバージョンが指定されていない場合は、該当 shard を最新の状態に更新します。

=== shard を作る

Crystal が標準で提供していない様々な機能を使えるようになる、というだけでも Shards が有用な仕組みだということはご理解いただけると思います。では、自作のライブラリを shard として公開するモチベーションとは何でしょう？

「世界中の Crystal 使いの人々に便利な機能を提供したい」という理由も当然アリです。ただ、そこまで肩肘を張らず「自分が便利だから」というだけでも、自作ライブラリを shard として公開する理由としては十分です。実際、複数のプロジェクトで共通使用する汎用部品は、仮に自分だけしか使わなかったとしても shard として公開しておくことでデプロイ時の手間やその後のメンテナンスをかなり省力化できます。

例えば、ライブラリを開発環境とは別の本番環境で使用したい場合、プロジェクト全体を tar で固めて scp で転送、なんてことをしがちです。こうした作業はただでさえ手間がかかりますが、使用するライブラリのバージョンが異なる複数のプロジェクトを維持していこうと思うと気が遠くなります。もしそのライブラリが shard として公開されていれば、プロジェクトディレクトリ内で `shard.yml` に 2 〜 3 行追加して `crystal deps` コマンドを実行するだけになります。さらに、必要であれば個々のプロジェクトごとに過去のバージョンを指定してインストールすることもできます。

これだけでも、自作ライブラリを shard 化しておくメリットはあると言えるのではないでしょうか。

「プログラミング言語の拡張ライブラリを公開する」というと敷居が高く感じられるかもしれませんが、Crystal の shard を公開する手順は比較的シンプルです。実際、Crystal コンパイラの機能で作成したひな型をベースにコードを書いて、特に何も考えずにそのまま GitHub へ公開するだけでも、とりあえず shard として使えてしまったりします。

とはいえ、ある程度は shard の体裁というものもありますので、ここからは公開リポジトリで shard を公開する際に必要な最低限の手順について説明したいと思います。

NOTE: 今回は作成した shard を GitHub 上で公開することを想定しています。GitHub や git の操作方法についてはすでにご存知だということを前提としていますので、これらの使い方は別途 Web サイトや書籍などをご参照ください。

==== shard の名前

アプリケーションを作成する場合と同様、何はともあれ shard として再利用したいライブラリに持たせる機能と、その名前を決める必要があります。機能については既にやりたいことがあるはずですが、一般に公開する shard の名前は意外と悩みどころです。

shard.yml ファイルの記述方法を定義した「 link:https://github.com/crystal-lang/shards/blob/master/SPEC.md[shard.yml specification.] 」には、shard の名前として以下のような命名規則が規定されています。

====
- 他の shard と重複しないこと

- 50 文字以下

- 英文字は小文字（`a`-`z`）を使用すべき

- 名前の一部に「 crystal 」を含むべきではない

- 数字（`0`-`9`）を含んでも良いが、先頭に置いてはならない

- アンダースコア（`_`）やダッシュ（`-`）を含んでも良いが、先頭や末尾に置いてはならない

- アンダースコアやダッシュが連続してはならない
====

基本的にこれらの条件に従う必要がありますが、shard 名の重複についてはそこまで厳密に考えなくても問題になることは少ないでしょう。単機能の shard 名は割とカブりがちですし、その名前を世界中の誰も使っていないことを確認することは実際には不可能です。とはいえ、最低でも標準添付のライブラリとカブるような名前は避けなければいけません。また、とりあえず CrystalShards.xyz で使いたい名前を検索して、ヒットするかどうかの確認くらいはしてみても良いかもしれません。

また、既存の例をいくつかみてみると、shard の命名法には大きく2つのパターンがあるようです。

====
1. `html_builder` や `mysql` など、機能をそのまま表した名前。単機能とは言わないまでも何か1つの対象に焦点を絞った shard に多い。

2. `kemal` や `topaz` など、機能とは関係なくプロダクトイメージなどからつけられた独自の名前。フレームワークなどある程度の規模を持ち、複数の機能から構成されている shard に多い。
====

これらを参考にわかり易い、またはカッコいい shard 名を考えてみてください。

ここでは整数 n に対して n 番目のフィボナッチ数を返してくれる shard を作ってみることにしましょう。単機能のシンプルな shard ですので、shard 名はそのまま `fibonacci` にします。

.shard 名はスネークケースで

****
命名規則上は shard 名にダッシュ記号も使えることになっていますが、基本的には単語の区切りにアンダースコアを使用するスネークケースで命名することをお勧めします。その理由は、一般的に shard 名はソースコードのファイル名にも使用されるためです。Crystal 公式ドキュメントの link:https://crystal-lang.org/docs/conventions/coding_style.html[コーディングスタイル]では、ソースファイルのパスを名前空間に合致させ、ファイル名として型名をスネークケースに変換したものを使用するよう推奨されています。

====
例:: `HTTP::WebSocket` -> http/web_socket.cr
====

shard 名をスネークケースで命名しておけば、プロジェクトひな形で生成されたソースファイル名をそのまま使用できます。

ちなみに、同コーディングスタイルでは、型名（クラス名やモジュール名）として複数の単語を先頭文字のみ大文字にしてそのまま連結したアッパーキャメルケースを使用することが推奨されています。`crystal init` コマンドによるプロジェクトひな型の自動生成でも、プロジェクト名をアッパーキャメルケースへ変換した名前で名前空間用のモジュールが定義されます。この点からも shard 名はスネークケースで付けておくと便利です。
****

==== プロジェクトひな形の作成

shard を作成する際も、それ用のプロジェクトを立ち上げることになります。プロジェクト名は特にこだわりがなければ shard 名と同じで構いません。というよりむしろ、ひな形で提供される各種ファイルを有効利用するには、プロジェクト名と shard 名をそろえておく方が良いでしょう。

独立したアプリケーションではなく、再利用可能なライブラリを作る場合のプロジェクトひな形生成コマンドは「 `crystal init lib プロジェクト名`」です。

.fibonacci shard 用プロジェクトのひな形生成コマンド

----
$ crystal init lib fibonacci
----

なお、ひな形として提供されるファイルやディレクトリの構成は、ライブラリであってもアプリケーションの場合と変わりません。

==== shard.yml の記述確認

shard を使用する際にも、使用したい shard の指定に `shard.yml` ファイルを使用しました。しかし、このファイルは本来プロジェクトを shard として公開する際のメタデータを記述するためのものです。

メタデータとして最低限必要な以下の情報がひな形生成時に自動的に取得されており、ある程度そのまま利用可能な状態になっています。

.ひな形生成時の shard.yml

[source, yaml]
----
include::projects/fibonacci/shard.yml[]
----

====
`name`:: shard の名前。プロジェクト名がそのまま使用される。

`version`:: shard のバージョン情報。ひな形生成時は `0.1.0` になっている。

`authors`:: shard 作成者のリスト（配列）。git の設定で `user.name` と `user.mail` が設定されていればそれらが使用される。

`crystal`:: shard が対応する Crystal のバージョン。ひな形を生成した `crystal` コマンドのバージョンが使用される。

`license`:: shard 公開時に採用するライセンスの種類。デフォルトでは `MIT` ライセンスが設定されている。
====

複数人で開発している場合に `authors` を追加する、`MIT` 以外のライセンスを `license` に指定するなど、必要に応じてこれらの値を変更してください。また、作りたい shard に別の shard の機能が必要であれば、アプリケーションを作成した際と同様に `dependencies` の設定を追加します。

fibonacci では他の shard を使用することもなく、特に変更すべき内容もありませんのでこのまま進めることにします。

===== shard.yml ファイルのフォーマット

拡張子が `.yml` となっていることからもわかる通り、`shard.yml` ファイルは YAML で書かれています。

「 shard.yml specification.」には、`shard.yml` のルールとして以下の条件が示されています。

- YAML ドキュメントとして構文的に正しいこと
- 文字コードは UTF-8 を使用すること
- 空白2文字でインデントすること
- 文字列、配列、ハッシュ以外の YAML の要素を使用しないこと

`shard.yml` を修正した場合は、これらの条件から外れないように注意しましょう。

また、「 shard.yml specification.」にはひな形で登場しない設定可能な項目なども説明されていますので、一度詳しく目を通しておくことをお勧めします。

==== spec テスト用のテストケースを書く

最近ではテスト駆動開発（test-driven development）や振る舞い駆動開発（behavior driven development）が流行りのようです。これらの手法では、まずパブリックなメソッドの想定される挙動（引数や返り値など）を定義してから、テストケースを使用した spec テストが通るようにソースコードを記述するという流れで開発を行います。

spec テスト実行機能がコンパイラに標準で用意されていたりすることから、Crystal としてはこうした開発方式を推奨しているように思えます。プロジェクトひな形にあらかじめ spec テスト用の構成が含まれていますので、ソースファイルにコードを書き始める前に、まずは `fibonacci` のテストケースを書いてみましょう。

[suppress='InvalidSymbol']
今回は shard 名（プロジェクト名）が fibonacci ですので、名前空間用のモジュールは `Fibonacci` になります。提供するメソッドは n 番目のフィボナッチ数を返す `Fibonacci.number(n)` のみ。引数 `n` は整数（`Int` 型のいずれか）でさえあれば良いでしょう。一方、出力されるフィボナッチ数は `n` が大きくなると急激に大きくなります。`n` が200を超える頃には128ビット整数でも表現しきれないサイズになりますので、ここは可変長整数（`BigInt`）型を使用することにします。また、あまり一般的ではありませんが、フィボナッチ数は `n` が負の場合も定義されています。せっかくですので、`n` が負のフィボナッチ数にも対応させることにしましょう。

.fibonacci shard の使用イメージ

[source, crystal]
----
require "fibonacci"


Fibonacci.number(-4) #=> -3_big_i
Fibonacci.number(-3) #=>  2_big_i
Fibonacci.number(-2) #=> -1_big_i
Fibonacci.number(-1) #=>  1_big_i
Fibonacci.number(0)  #=>  0_big_i
Fibonacci.number(1)  #=>  1_big_i
Fibonacci.number(2)  #=>  1_big_i
Fibonacci.number(3)  #=>  2_big_i
Fibonacci.number(4)  #=>  3_big_i
----

プロジェクトひな形にはテストケースを記述するための spec ファイル （`spec/fibonacci_spec.cr`）が用意されており、あらかじめ以下のようなテストケースが記述されています。

.ひな形生成時の fibonacci_spec.cr
[source, crystal]
----
require "./spec_helper"

describe Fibonacci do
  # TODO: Write tests

  it "works" do
    false.should eq(true)
  end
end
----

とはいえ、ここで定義されているテストケースは「 `fales` は `true` と等しいはず」という内容なので、当然ながらこの状態で spec テストを実行しても必ず不合格になります。

fibonacci の挙動に合わせて spec ファイルに必要なテストケースを記述すると以下のようになりました。

.テストケースを記述した fibonacci_spec.cr

[source, crystal]
----
include::projects/fibonacci/spec/fibonacci_spec.cr[]
----

テストケースの書き方はこの章の最後で詳しく紹介しますので、ここでは「そういうものだ」として先へ進んでください。

==== 機能の実装

必要なテストケースが準備できたら、次はそのテストケースを満足させる機能を実装していきます。 spec テストはパブリックなインタフェース（メソッド）の入出力を定義しているだけですので、メソッドがどう実装されるかは気にしません。

fibonacci の実装方法も何パターンか考えられますが、とりあえず、一度計算した内容のキャッシュくらいは持てるように実装してみたのが以下のコードです。

.fibonacci のソースコード

[source, crystal]
----
include::projects/fibonacci/src/fibonacci.cr[]
----

==== spec テストの実行

spec テストの実行コマンドは `crystal spec` です。プロジェクトディレクトリの直下でこのコマンドを実行すると、テストケースが順番に実行され、実際の挙動が指定された結果に合致しているかどうかがチェックされます。

.spec テスト実行結果

----
$ crystal spec
...

Finished in 203 microseconds
3 examples, 0 failures, 0 errors, 0 pending
$
----

テスト結果の先頭行には `it` ブロックごとに実際の挙動がテストで想定された通りであれば `.` が表示されます。もしここに `.` 以外の文字が表示されているようであれば、対応した `it` ブロック内でテストした機能の実装に問題があることになります。まずは先頭行がすべて `.` になるまで、ソースコードの修正とテストを繰り返しましょう。

今回の spec ファイルには `it` ブロックが3つあり、上の例では `.` が3つ並んでいます。ということは、実装したソースコードは当初想定した通りの挙動をしているようですね。

このように、 spec テストが成功した時点で shard の機能面は完成です。実際、この状態でも GitHub へ公開すれば、shard として使用できてしまったりします。しかし、曲がりなりにも一般公開する shard には、それなりの体裁といったものもありますので、もうひと手間ふた手間かけてみることにしましょう。

==== README を書く

ひな形生成時に用意されている `README.md` ファイルは、GitHub での公開を前提としています。そのため、GitHub で shard を 公開する場合には、以下の2点を修正するだけで標準的な README として利用できるようになっています。

[suppress='SuggestExpression']
1. 何箇所かある `[your-github-name]` を自分の GitHub アカウントに置き換える

2. `TODO:` の部分を埋めていく

.README.md 中に登場する TODO: 項目
`TODO: Write a description here`:: その shard の概要。最低限、なにをする shard なのかくらいは書いておいた方が良い。

`TODO: Write usage instructions here`:: その shard の使い方。ある程度サンプルコードで代用可能。

`TODO: Write development instructions here`:: その shard の開発に関わろうとする人向けの情報。積極的に開発者を募るつもりがなければ、`## Contributing` と一緒に `## Development` の項目ごと削除するという手も。

というわけで、最低限の項目を記載した `README.md` は以下のようになりました。

.完成した README.md

[source, markdown]
----
include::projects/fibonacci/README.md[]
----

==== ライセンスを選ぶ

プロジェクトのひな形では、shard を公開する際のライセンスとして、`MIT` ライセンスが選択されています。

`shard.yml` の `license` には `MIT` が設定され、プロジェクトディレクトリ内の `LICENSE` ファイルも `MIT` ライセンスの条項が記載されています。

`MIT` ライセンスは2015年時点の統計では、その当時 GitHub で公開されていたリポジトリの4割以上が採用してたというメジャーなオープンソース向けのライセンスです。その内容は、ざっくり言うと「著作権表記とライセンス条項さえ含まれていれば有償無償問わず自由に使って良い、ただし無保証」というものです。ソフトウェアを使う側からすると比較的自由に利用でき、開発者としては免責が明言されているため、比較的使いやすいライセンスの1つです。大した量ではありませんので、詳細については一度 `LICENSE` ファイルの内容を読んでみてください。

もし `MIT` 以外のライセンスを採用したければ、`LICENSE` ファイルの内容を使用したいライセンス条件に書き換えた上、`shard.yml` の `license` を変更してください。`shard.yml` の `license` には OSI（Open Source Initiative）で定義されたライセンス名か、ライセンスの参照先 URL を指定できます。

`fibonacci` は特にライセンスへのこだわりはありませんので、`MIT` ライセンスのままで行こうと思います。

==== GitHub へ公開する

README を書き終わったら、プロジェクトを GitHub へプッシュして公開しましょう。この辺りの手順は GitHub のドキュメントなどを参照してください。

プロジェクトが GitHub へ公開されたことで、別のプロジェクトに `shard.yml` に以下の記述を追加して `fibonacci` をインストール可能になりました。

[source, yaml]
----
dependencies:
  fibonacci:
    github: github_name/fibonacci
----

ここまでで shard を作って公開するまでの手順は完了です。

ただし、この状態では `crystal deps` コマンドは shard のバージョンを認識できません。`shard.yml` の `dependencies` でバージョン指定されていたとしても、常に最新状態（リポジトリの HEAD）がインストールされてしまいます。

shard を作る手順の最後に、shard のバージョン管理方法についてご紹介しましょう。

==== shard のバージョン管理

毎度おなじみ「 shard.yml specification.」には、shard のバージョンとして以下のようなルールが示されています。

====
- link:https://semver.org/lang/ja/[セマンティックバージョニング]に従うことが望ましい

- 数字が含まれていること

- `.` や `-` を使用しても良いが、連続しないこと

例:: `0.0.1`、`1.2.3`、`2.0.0-rc1` など

ルールとして強制はされないものの、セマンティックバージョニングのように合理的なバージョン付けを強く推奨。
====

もし、後方互換が損なわれる大きな変更でも、内部の子細なバグフィックスでもメジャーバージョンが上がるようでは、使う側としてバージョンの変化からバージョンアップのインパクトを測りかねてしまいます。

[suppress='InvalidSymbol']
セマンティックバージョニングではメジャー/マイナ/パッチの3つの数字でバージョンを構成し、パッチよりマイナ、マイナよりメジャーバージョンが上がることのインパクトが大きくなるよう定義されています。`shard.yml` 内でバージョンを指定する際の `~>` 演算子は、セマンティックバージョニングのような、先頭に近い数字の変更がインパクトが大きい際に有効に働きます。

===== 3つのバージョン情報

`fibonacci` プロジェクトでは、プロジェクトファイルの2箇所に shard のバージョンが登場します。まず `shard.yml` ファイル2行目の `version`、もう1つが `src/fibonacci/version.cr` ファイルで定義されている `Fibonacci::VERSION` 定数です。この2つの値は、ひな形生成時にはどちらも `0.1.0` となっており、これがプロジェクト（shard）のバージョンになります。

前述の通り、`shard.yml` と `src/fibonacci/version.cr` にバージョンが書かれていても、`crystal deps` コマンドはそのバージョンを認識できません。

この時使用されるのが第三のバージョン情報、git リポジトリのバージョンタグです。

`shard.yml` の `dependencies` 内で、ある shard のバージョンとして `1.0.0` が指定されていたとしましょう。このとき、`crystal deps` コマンドは、その shard のリポジトリから `v1.0.0` とタグ付けされたコミットの状態をインストール対象とみなします。

つまり、先ほどプッシュした `fibonacci` の GitHub リポジトリに `v0.1.0` というタグを付けることで、`fibonacci` がバージョン `0.1.0` だと明示できます。なお、リポジトリの公開先が GitHub なのであればリリース管理機能を使って新しいリリースを追加する一環として、Web UI からバージョンタグを設定できます。

もし `fibonacci` の機能に修正を加えてバージョンを `0.2.0` へ上げる場合には以下のような手順で行うことになるでしょう。

====
1. `fibonacci` の機能を修正

2. `src/fibonacci/version.cr` の `VERSION` 定数を `0.2.0` に変更

3. `shard.yml` 2行目の `version` を `0.2.0` に変更

4. 変更をコミットし、GitHub 上の master ブランチへマージ

5. GitHub 上で変更がマージされた master ブランチにバージョンタグ `v0.2.0` を追加
====

こうしておくと複数のプロジェクトからそれぞれ異なるバージョンの shard を利用可能になります。

というわけで、以上が shard を作って公開し、さらに他のプロジェクトから使用してもらうために必要な作業の流れになります。

.shard を作る手順のまとめ
****
1. shard 用のプロジェクトを作成する（`crystal init` コマンド）

2. `shard.yml` にメタデータを記述する

3. spec テストのテストケースを書く

4. テストケースを満足させるようにソースファイルに機能を実装する

5. spec テストを実行し、問題があれば修正する

6. README を書く

7. ライセンスを選ぶ

8. GiuHub などのリポジトリへ公開する

9. git リポジトリにバージョンタグを付ける
****

=== spec テスト

この章の最後に、shard を作る際にも使用した spec テストについて簡単にご紹介します。

spec テストはユニットテストの一種で、プログラムが想定した通りの挙動を取るかどうかを調べる機能試験に相当します。これは、あらかじめ「このメソッドにこういった引数を与えると、こんな結果になるはず」というプログラムの挙動（テストケース）を列挙しておき、実際にそうなるかどうかを個々にチェックするイメージです。

Crystal には、RSpec を参考にした spec テスト機能を提供するモジュール `Spec` がコンパイラ自身の標準添付ライブラリとして用意されています。また、標準のプロジェクトひな形に spec テスト用のファイル一式が含まれているなど、言語自体が spec テストを強く意識した作りになっています。

==== spec テストの使い方

細かい説明は後ですることにして、まずは spec テストの使い方をざっくり見てみましょう。

===== spec ファイルを作る

まず、spec テストにはテストケースを記述した spec ファイルが必要です。spec ファイルは、 `"spec"` とテスト対象となるコードを `require` した Crystal のソースファイルで、テストケース自体も Crystal のコードとして記述します。

さて、ここでは簡単な例として `"がおー"` と吠える `Bear` クラスを実装する場合を考えてみましょう。`Bear` クラスが持つインスタンスメソッドは吠え声を文字列で返す `#bark` のみ、ソースファイル名は `bear.cr` です。

[suppress='InvalidSymbol']
spec ファイルの名前は `\\***_spec.cr` と付けられることが多く、`***` の部分にはテスト対象とするソースファイルのベースネームが使用されることが一般的です。今回もその例に倣って、熊がちゃんと `"がおー"` と吠えるかどうかテストする `bear_spec.cr` を、ソースファイルと同じディレクトリに作ってみました。

.bear_spec.cr

[source, crystal]
----
include::examples/bear_spec.cr[]
----

最初の2行は `Spec` モジュールとソースコードの `require` ですので、4行目以降がテストケースの記述部分になります。

まず登場するのが `describe Bear` で宣言されたブロックです。これは、その内部で行われるテストが `Bear` 型を対象としていることを明示しています。`describe Bear` ブロックの中には、もう1つ `describe "#bart"` ブロックが置かれています。こちらのブロックはその内部で `Bear` 型の中でも `#bart` メソッドに関するテストを行うことを宣言しています。

続いて登場するのがテストケース1つに相当する `it` ブロックです。`it` ブロックでは、`describe` で宣言された対象となるメソッドのある1つの振る舞いについて、想定される挙動と実際の挙動が合致しているかどうかをチェックします。また、`it` ブロックには引数としてその内部で行うテストの内容を説明するための文字列を与えることができます。この例では、`it`（`Bear#bart` メソッド）が、正しく `"がおー"` という文字列を返すかどうかについてテストすることが説明されています。

そして、`it` ブロックの内で実行される `Bear.new.bark.should eq "がおー"` が実際にチェックされる条件の定義です。`Bear.new.bark` が `"がおー"` と等しく（`eq`）あるべき（`should`）、といったようにの実際にチェックしている内容が（英語として）比較的自然に読める構文になっています。

===== プログラム本体を実装する

さて、spec ファイルが用意できたので次に `Bear` クラスそのものを `bear.cr` へ実装していくのですが、うっかり熊に `"わん"` と吠えさせてしまいました。

.実装ミスを含んだ bear.cr

[source, crystal]
----
include::examples/bear0.cr[]
----

===== spec テストを実行する

この状態で spec テストを実行してみるとどうなるでしょうか。

.spec テストの実行結果

[source]
----
include::examples/spec_error.txt[]
----

テスト結果の先頭行には、テストケース（`it` ブロック）ごとの実行結果サマリが、それぞれ1文字で出力されます。今回はテストケースが1つしかありませんので、表示されているのは `F` 1文字だけです。テスト結果 `F` は、実際の挙動がテストケースで指定された条件とは異なる結果を示したため、テストが不合格になった場合に表示されるものです。

このように何らかの理由でテストが不合格になると、`Failures:` に続いて具体的な問題点が出力されます。ここでは、期待された値（`Expected:`）が `"がおー"` なのに対して、実際の結果（`got:`）が `"わん"` になっていたことが確認できます。このように、spec テストを行うと、実装されたコードが想定されたものとは異なる挙動を示した際に、どの部分がどのように異なっていたのかを具体的に知ることができます。

===== テスト結果を元にソースを修正する

テスト結果から問題の箇所は明らかですので、`bear.cr` の実装を修正しました。

.修正後の bear.cr

[source, crystal]
----
include::examples/bear.cr[]
----

===== 再度 spec テストを実行して修正結果を確認する

もう一度 spec テストを実行してみると、今度は `F` ではなく `.` が表示されましたので、実装したコードが当初想定した通りの機能を実現できていることが確認できました。

.spec テストの実行結果（ソース修正後）

----
include::examples/spec_success.txt[]
----

このように、まず実装しようとする機能の挙動をテストケースとして定義し、テストケースを満足するように実装を進める開発手法を、テスト駆動開発や振る舞い駆動開発などと呼びます。この手法のメリットとしては、実装コードの品質が担保されるという点はもちろんありますが、テストケース自体がある意味で機能仕様やサンプルコードとして利用できるという点も見逃せません。チームで開発している場合や他の人が書いたコードを引き継ぐ場合など、最低限の情報はテストケースから入手できます。

では次に、spec ファイルで使用する各構文についてみてみましょう。

==== グルーピング用ブロック

グルーピング用ブロックは、1つ以上のテストケースを何らかの基準でまとめるために使用されます。グルーピング用ブロックの内部には次に紹介するテストケース用のブロックだけでなく、別のグルーピング用ブロックをネストさせることも可能です。

先の例では `describe` ブロックが登場しましたが、これはテスト対象を元にしたグルーピングを行います。`describe` ブロックにはテスト対象として型（クラス、モジュールなど）やメソッド名（文字列で指定）を引数として与えることができます。この引数はテスト不合格時の出力メッセージでも利用されるため、テスト対象となるメソッド名に準じた構成をとることが強く推奨されています。例えば、外側の `describe` では型を指定し、内側の `describe` にメソッド名を渡すような形です。さらにこのとき、引数がクラスメソッドの場合には `.` を、インスタンスメソッドの場合には `#` をメソッド名の先頭に付けましょう。そうすることで、外側と内側の引数を組み合わせて `Class #method` のように準的なメソッド表記に近い形を再現できます。

また、Crystal の spec ファイルでは、グルーピング用のブロックとして `describe` 以外にもう1つ `context` 使用できます。`describe` ブロックがテスト対象をもとにしたグルーピングだとすると、`context` ブロックはその時の状況（条件）によるグルーピングです。例えば、配列が要素を含んでいるか否かで挙動が異なる場合に、それぞれの状況を明確にすることができます。

.describe と context

[source, crystal]
----
include::examples/spec_example_00.cr[]
----

==== テストケース用ブロック

こちらの例としては `it` がすでに登場しています。`it` はあるメソッドがもつ特定の挙動1つについてのテストケースを記述するためのブロックです。複数の挙動に対するテストケースを1つの `it` ブロック内に記述すべきではありません。例えば、オブジェクトの状態にや引数の値によって異なる挙動を示すような場合は、同じメソッドであってもそれぞれに独立した `it` ブロックを設けてテストケースを定義すべきです。

テストケースを書くためのブロックには `it` ともう1つ、`pending` があります。`pending` ブロックは文字通り、一時的にそのテストケースの実行を保留する場合に使用します。例えば、機能仕様としてのテストケースは定義されたものの対象となるメソッドがまだ実装されていない場合には、`it` の代わりに `pending` ブロックを使用すると良いでしょう。ただし、あくまで **一時的に保留しておく** だけですので、最終的には `pending` ブロックを `it` ブロックに置き換えてテストに合格できるようにしなければいけません。

.it と pending

[source, crystal]
----
include::examples/bear1_spec.cr[]
----

[suppress='InvalidSymbol']
==== オブジェクトの状態チェック

`require "spec"` が実行されると、全てのオブジェクトに対して `#should` と `#should_not` という2つのインスタンスメソッドが追加されます。`#should` は、レシーバの状態に対する条件（`eq "がおー"` など）を引数に取り、実際の値がその条件を満たしていない場合、テストは不合格になります。一方、`#should_not` は逆に条件を満たしてしまうとテストが不合格になります。

オブジェクトの状態に対するチェック条件には以下のような種類があります。一部のチェック条件は特定のインスタンスメソッドを持たないオブジェクトに対しては使用できません。例えば、`should be` を使用するには `#same?` が実装されている必要があります。

.使用可能なオブジェクトの状態チェック

`actual.sould eq expected`:: `actual` が `expected` と等しいかどうか。
 条件： `actual == expected`

`actual.sould be expected`:: `actual` が `expected` 同値とみなせるかどうか。条件： `actual.same?(expected)`

`actual.sould be_a expected`:: `actual` が `expected` 型の値かどうか。条件： `actual.is_a?(expected)`

`actual.sould be_nil`:: `actual` が `nil` かどうか。条件： `actual.nil?`

`actual.should be_true`:: `acrual` が `true` かどうか。条件： `actual == true`

`actual.should be_false`:: `acrual` が `false` かどうか。条件： `actual == false`

`actual.should be_false`:: `acrual` が `false` かどうか。条件： `actual == false`

`actual.should be_truthy`:: `acrual` が `if` 文で真とみなされる。条件： `acrual` が `false`、`nil`、`Pointer.null` のいずれでもない

`actual.should be_falsey`:: `acrual` が `if` 文で偽とみなされる。条件： `acrual` が `false`、`nil`、`Pointer.null` のいずれか

`actual.should be < expected`:: `actual` が `expected` より小さいかどうか。条件： `actual < expected`

`actual.should be <= expected`:: `actual` が `expected` 以下かどうか。条件： `actual <= expected`

`actual.should be > expected`:: `actual` が `expected` より大きいかどうか。条件： `actual > expected`

`actual.should be >= expected`:: `actual` が `expected` 以上かどうか。条件： `actual >= expected`

`actual.should be_close(expected, delta)`:: `actual` と `expexted` の差が `delta` 以下かどうか。条件： `(actual - expected).abs <= delta`

`actual.should contain expected`:: `actual` が `expexted` を含むかどうか。条件： `actual.includes?(expected)`

`actual.should match expected`:: `actual` が `expexted` にマッチするかどうか。条件： `actual =~ expected`

==== 例外の発生チェック

`expext_raises` ブロックに引数として例外の型を指定して使用すると、ブロック内で指定した型の例外が発生することをチェックできます。

.例外チェック

[source, crystal]
----
include::examples/spec_example_01.cr[]
----

このとき、引数に文字列もしくは正規表現オブジェクトを追加することで、エラーメッセージに対する条件を指定することも可能です。

.メッセージ条件付き例外チェック

`expect_raises(SomeError, "message") { ... }`:: エラーメッセージに `"message"` が含まれる `SomeError` 型の例外が発生しなければ不合格。

`expect_raises(SomeError, / pattern /) { ... }`:: エラーメッセージが `/pattern` にマッチする `SomeError` 型の例外が発生しなければ不合格。

なお、発生した例外の状態を他のチェック条件でテストする場合には、`expect_raises` の返り値として例外インスタンスを取得できます。

==== spec テスト実行結果の見方

テストの実行結果は大きく分けると以下のパートから構成されます。

1. テストケースの実行結果サマリ

2. 不合格となったテストケースの詳細情報

3. テストの実行に要した時間

4. テスト結果の統計情報

5. 不合格となったテストケースの一覧

このうち、2. および 5. については、どのテストケースでにもエラーが発生しなかった場合には表示されません。

ソース修正前の `bear_spec.cr` の実行結果を例に、それぞれの内容を詳しくみてみましょう。

===== テストケースの実行結果サマリ

[source]
----
include::examples/spec_error.txt[lines=2..2]
----

テストケースの実行結果には成功（`.`）、不合格（`F`）、エラー（`E`）、ペンディング（`*`）の4種類があります。spec テストの実行結果では、先頭行にテストケースの数だけ実行結果に対応した文字が並んで表示されます。もし spec テストを実行したのがカラー表示対応のターミナルであれば `.` は緑、`F` と `E` が赤、`*` が黄色で表示されているかもしれません。

ここで表示される実行結果が全て `.` になっていれば、spec テストに合格したことになります。

.終了ステータスの種類

成功（`.`）:: テストケース内のチェック条件を全てパスし、想定外の例外やエラーも発生しなかった場合。

不合格（`F`）:: テストケース内のチェック条件を満たさない項目が存在した場合。

エラー（`E`）:: テストケース内で `expect_raises` で補足されない想定外の例外が発生した場合

ペンディング(`*`):: テストケースが `pending` ブロックとして定義されており、テストの実行を保留している場合。

===== 不合格となったテストケースの詳細情報

[source]
----
include::examples/spec_error.txt[lines=4..12]
----

`Failures:` に続くのは不合格となったテストケースの具体的な問題点が出力されます。

.不合格テストケースの情報

1. 不合格テストケースの通し番号とテストケースの説明（3行目）

2. 不合格の原因となったチェック項目（4行目）

3. 想定された状態（`Expected:`）と実際の状態（`got:`）（6〜7行目）

4. 該当チェック項目があるファイル名と行番号（9行目）

===== テストの実行に要した時間

[source]
----
include::examples/spec_error.txt[lines=14..14]
----

参考までに。

===== テスト結果の統計情報

[source]
----
include::examples/spec_error.txt[lines=15..15]
----

ここには `examples`、`failures`、`errors`、`pending` と4種類の数値が出力されます。

`examples` が spec ファイルに定義されたテストケースの数、後ろ3つは、実行結果が不合格/エラー/ペンディングとなったテストケースの数です。

ここで後ろ3つの値がゼロになっていれば、テストに合格したことになります。

===== 不合格となったテストケースの一覧

[source]
----
include::examples/spec_error.txt[lines=17..19]
----

最後に、不合格となったテストケースについて、個別にチェックする場合の `crystal spec` コマンドが一覧で表示されます。

リスト各行の `#` から後ろは、どのテストケースについてのものなのかを識別するためのコメントです。

`#` よりも前の部分、この例でいう `crystal spec bear_spec.cr:6` を実行することで、問題となったテストケースだけを対象としてテストを実行できます。

==== crystal spec コマンドのパラメータ

spec テストを実行する `crystal spec` コマンドには、パラメータとしてディレクトリや単体の spec ファイル、さらには特定のテストケースを指定してテストを実行できます。

.crystal spec コマンドへのパラメータ指定

`crystal spec`:: デフォルトの挙動。`spec/**/*_spec.cr` にマッチする全ての spec ファイルを対象とする。

`crystal spec dir/`:: ディレクトリを指定した場合。`dir/**/*_spec.cr` マッチする全ての spec ファイルを対象とする。

`crystal spec spec_file.cr`:: spec ファイルを指定した場合。`spec_file.cr` 単体を対象とする。

`crystal spec file.cr:10`:: spec ファイルと行数を指定した場合。`spec_file.cr` ファイルの10行目から始まるブロックだけを対象とする。

大規模なソースコードをのテストを実施する際には、これらのパラメータを有効活用することでテスト効率を向上できるかもしれません。
