== 構文

この章では Crystal の構文について説明します。

Crystal の構文は Ruby によく似ているため、Ruby と比較しながら説明することが多くなります。Ruby の構文については以下の資料などを参考にしてください。

* https://docs.ruby-lang.org/ja/latest/doc/index.html[オブジェクト指向スクリプト言語 Ruby リファレンスマニュアル]

また、この章の内容は Crystal 公式ドキュメントの https://crystal-lang.org/docs/syntax_and_semantics/[Syntax and Semantics] を大きく参考にしています。

=== コメント

コメントは `#` から始めます。

[source,crystal]
----
include::./examples/comment.cr[]
----

NOTE: Ruby にある `=begin` と `=end` による複数行のコメントは Crystal はサポートしていないので注意してください。

=== リテラル

Crystal にはこれらのリテラルがあります。

- `nil`
- 論理値
- 数値
- シンボル
- *文字*
- 文字列
- 配列
- ハッシュ
- 範囲
- 正規表現
- *タプル*
- *名前付きタプル*
- Proc

ここではこれらを紹介していきます。

NOTE: *文字*、*タプル*、*名前付きタプル*は Ruby には存在しないものです。

==== `nil`

何も無い値を意味する `nil` というリテラルがあります。

これは Java の `null` や Python の `Nothing` に相当します。

[source,crystal]
----
include::./examples/nil.cr[]
----

Crystal では `nil` はかなり特殊な値で、 `nil` を含む値を便利に扱うための構文がいくつか存在します。

==== 論理値

論理値は `Bool` 型の値で、 `true` と `false` です。

[source,crystal]
----
include::./examples/bool.cr[]
----

==== 数値リテラル

数値リテラルも Ruby や多くの言語と同じような構文になっています。

[source,crystal]
----
include::./examples/number.cr[]
----

いくつか特殊な点があるとすれば、数値リテラルの区切りに `_` を使えるところと、 `i64` や `f32` などの接尾辞を付けることで数値リテラルの型を明示できるところがあります。

例えば、 `100i64` は `Int64` 型（64ビットの符号付き整数型）の `100` になります。
同様に `100u64` は `UInt64` 型（64ビットの符号なし整数型）の `100` になります。

末尾に何も付いていない場合、整数リテラルなら `Int32` 型、小数点や指数があれば `Float64` 型になります。

.数値リテラルの接尾辞の種類
[cols="2*1,3",options=header,width=70%]
|===
|接尾辞|型|説明

| `i8`   | `Int8`   | 8ビットの符号付き整数型
| `i16`  | `Int16`  | 16ビットの符号付き整数型
| `i32`  | `Int32`  | 32ビットの符号付き整数型
| `i64`  | `Int64`  | 64ビットの符号付き整数型
| `i128` | `Int128` | 128ビットの符号付き整数型

| `u8`   | `UInt8`   | 8ビットの符号なし整数型
| `u16`  | `UInt16`  | 16ビットの符号なし整数型
| `u32`  | `UInt32`  | 32ビットの符号なし整数型
| `u64`  | `UInt64`  | 64ビットの符号なし整数型
| `u128` | `UInt128` | 128ビットの符号なし整数型

| `f32` | `Float32` | 32ビットの浮動小数点型
| `f64` | `Float64` | 64ビットの浮動小数点型
|===

==== シンボル

シンボルは変更できない文字列のようなもので、Ruby と大体同じ構文です。

`:` から始まる単語はシンボルになります。

NOTE: Crystal では Ruby ほどシンボルを使いません。なぜならば `String#intern` や `String#to_symbol` などのメソッドが無く、プログラム中で動的にシンボルを生成することが不可能だからです。また、シンボルリテラルの中に `#{}` を含めて実行時にシンボルの値を決めることもできません。

[source,crystal]
----
include::./examples/symbol.cr[]
----

NOTE: Crystal は Ruby にある `%s` 形式のシンボルリテラルをサポートしていません。

==== 文字と文字列

NOTE: Crystal は型のある言語なので、Ruby とは異なり文字と文字列を区別します。

文字リテラルは `'` で囲まれた文字です。

[source,crystal]
----
include::./examples/char.cr[]
----

当然ですが、文字リテラルなので `'` の中に二文字以上の文字を含むと構文エラーになります。

文字列リテラルは `"` で囲む形式や `%` から始まる形式、ヒアドキュメントという3つの形式が存在します。

[source,crystal]
----
include::./examples/string.cr[]
----

==== 配列

配列も Ruby と同じように `[` と `]` の中に `,` で要素を区切って配置します。

文字列の配列には `%w` から始まる形式が利用できます。

[source,crystal]
----
include::./examples/array.cr[]
----

Ruby と大きく異なるのは空の配列を作る際に、`of` に続けて型を明記しなければいけないところです。
現在の型推論では空の配列がどんな型の要素を持つか正しく推論できないためです。
同じような制約が Hash にもあります。

[source,crystal]
----
include::./examples/empty-array.cr[]
----

また、一度作った配列の型は後から変更できません。
つまり、数値の配列に文字列を追加したら数値と文字列の配列になる、といったことは無く、コンパイル時にエラーになります。

[source,crystal]
----
include::./examples/push-array.cr[]
----

==== ハッシュ

ハッシュも Ruby と同じように `{` と `}` の中に `=>` の左右にキーとバリューを置いたものを `,` で区切って配置します。

Ruby にある `:` で区切るとキーがシンボルになる形式は Crystal では名前付きタプルになるので使えません。

[source,crystal]
----
include::./examples/hash.cr[]
----

==== 範囲

範囲も Ruby と同じで、 `..` か `\...` の左右に範囲の始まりと終わりの値を置きます。

`..` と `\...` の違いは、 `..` は終わりの値を含んで、 `\...` は終わりの値を含まないところです。

[source,crystal]
----
include::./examples/range.cr[]
----

==== 正規表現

正規表現も Ruby と同じで `/` で囲みます。

また `%r` から始まる形式も利用できます。

[source,crystal]
----
include::./examples/regex.cr[]
----

NOTE: Ruby では正規表現のクラスは `Regexp` ですが、Crystal では `Regex` です。

NOTE: Ruby の正規表現エンジンは Onigmo ですが、 Crystal は PCRE です。なので、使える構文に差異があることに注意してください。

// Onigmo と PCRE の違いについて触れる。

==== タプル、名前付きタプル

タプルと名前付きタプルは Ruby には無い概念です。

タプルは配列のようなものですが、大きさが固定で変更できません。
配列の構文を `[]` を使うところを `{}` に変えたような構文になります。

名前付きタプルはハッシュのようなものですが、キーにシンボル以外取れず、大きさが固定で変更できません。
ハッシュの構文にある `=>` を `:` に変えたような構文になります。

タプルはスプラット展開してメソッドの引数に渡す際に使います。
名前付きタプルはスプラット展開してメソッドの名前付き引数に渡す際に使います。

[source,crystal]
----
include::./examples/tuple.cr[]
----

==== Proc

`Proc` も Ruby と同じように `\->` で作れますが、引数の型を明示しなければいけません。

[source,crystal]
----
include::./examples/proc.cr[]
----

Crystal では Ruby ほど `Proc` を使いません。

=== 変数

変数は `=` で代入できて、その名前で参照できます。

また、複数代入もできます。

[source,crystal]
----
include::./examples/variable.cr[]
----

=== 定数

定数も `=` で定義できます。
定数の名前は大文字でなければいけません。

[source,crystal]
----
include::./examples/constant.cr[tag=file]
----

=== 条件分岐と繰り返し構文

Crystal にも Ruby とほぼ同等の条件分岐・繰り返しの構文があり、大体同じように使えます。

==== 条件分岐の構文

- `if`、`elsif`、`else`
- `unless`
- `case`、`when`
- 三項演算子

`case` 構文では内部的には Ruby と同じように `===` 演算子を使います。

[source,crystal]
----
include::./examples/conditional.cr[]
----

==== 繰り返しの構文

- `while`
- `until`

NOTE: Crystal には後置 `while` ・後置 `until` はありません。

[source,crystal]
----
include::./examples/repeat.cr[]
----

=== `require`

Crystal では `require` はメソッドではなく構文です。

別のファイルを読み込み、定義などを取り入れます。

`./` から始まるパスは、そのファイルからの相対パスを意味して、そうでないパスはライブラリのパスを意味します。

`**` で終わるパスはディレクトリを再帰的に読んで Crystal のファイルを読み込み、 `*` で終わるパスの場合はそのディレクトリにある Crystal のファイルを全て読み込みます。

パスがディレクトリ名の場合、ディレクトリにある同名のファイルを読み込みます。
例えば `./foo` と `foo` ディレクトリを読んだ場合、 `foo/foo.cr` を読み込みます。

[source,crystal]
----
include::./examples/require.cr[]
----

[suppress='InvalidSymbol']
==== 型制限

これらの条件部分に単純に変数を渡して `nil` かどうか確かめたり、 `is_a?` を使って変数の型を確かめたりすると、それによって変数の型が制限されます。

[source,crystal]
----
include::./examples/restriction.cr[]
----

=== 型とメソッド

==== クラス・メソッドの定義

[source,crystal]
----
include::./examples/class.cr[tag=file]
----

クラスは `class` キーワードで定義します。
クラス名は大文字から始めなければいけません。
定義した `class` は `new` クラスメソッドでインスタンス化できます。
継承は Ruby と同様に `<` で出来ます。

メソッドは `def` キーワードで定義します。
メソッド名は大文字からは始められません。
返り値は最後に実行した式の値になります。

==== `initialize`・インスタンス変数

コンストラクタは `initialize` メソッドで定義できます。

`@` から始まる変数はインスタンス変数になります。
メソッドの引数にインスタンス変数を指定すると、そのメソッドの呼び出しと共にインスタンス変数に代入されます。
インスタンス変数の型はコンパイル時に決定できるようになっていなければなりません。

[source,crystal]
----
include::./examples/initialize.cr[tag=file]
----

==== `protected`、`private`

`def` の前に `protected`、`private` を置くとメソッドの可視性を変更できます。

  - `private` の場合、メソッドはレシーバーの無い形式でしか呼び出せません。
  - `protected` の場合、メソッドは自身か継承先のクラスの中でしか呼び出せません。

トップレベルのメソッドに対しては `private` が指定できます。この場合、そのファイルでのみ参照できるメソッドになります。

また、クラス内の定数にも `private` を指定することができて、その場合は `::` を使った参照ができなくなります。

==== デフォルト引数・型制限・オーバーロード

デフォルト引数は、引数に続いて `=` で指定します。

引数に続いて `:` のあとに型を指定すると、引数がその型で制限されます。
型の制限された引数のあるメソッドを、その型以外で呼ぼうとするとコンパイル時にエラーになります。

異なる引数の数、型制限で同名のメソッドを定義した場合、実行時に適切な型のものが選択されて呼び出されます。

[source,crystal]
----
include::./examples/default.cr[tag=file]
----
