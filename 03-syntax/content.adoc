== 構文

この章では Crystal の構文について説明します。

Crystal の構文を全て説明すると膨大になってしまうので、ここでは Ruby との違いに焦点を置いて解説したいと思います。
というのも、 Crystal の構文は Ruby の影響を強く受けており、多くの場合 Ruby のように書くことで Crystal のプログラムを書くことができます。
しかし、やはり Crystal と Ruby は別のプログラミング言語であり、構文の異なる部分もいくつか存在します。
既に知識があるのであれば、その違いを抑えていくのが Crystal の構文を理解する手助けになるでしょう。

Rubyの構文については次のサイトを参考にしてください。

https://docs.ruby-lang.org/ja/latest/doc/index.html[オブジェクト指向スクリプト言語 Ruby リファレンスマニュアル]

また、Crystal の完全な構文は、公式サイトにある次のドキュメントを参考にしてください。

https://crystal-lang.org/docs/syntax_and_semantics/[Syntax and Semantics]


=== Crystal と Ruby の違い

Crystal と Ruby は構文こそよく似ていますが、言語としては次のような大きな違いがあります。

  1. Ruby はインタープリタで実行されるが、 Crystal はコンパイルして実行する。
  2. Ruby には変数に型が無いが、 Crystal には型がある。

そして、この二つが Crystal と Ruby の構文に違いをもたらしています。

前者を実感する例としては、こんなものがあります。
これは有効な Ruby のプログラムですが、 Crystal ではコンパイルエラーになります。

Crystal は `require` で読み込むファイルまで含めてコンパイルしなければなりません。
なので `require` は Ruby のようなメソッドではなく、構文として提供されていて、引数は固定の文字列ではなければいけないのです。

[source,ruby]
----
include::./examples/example1.rb[]
----

後者を実感する例としては、こんなものがあります。
これは Crystal のプログラムです。

メソッドの引数に型を指定しているところに注目してください。
引数の型でメソッドをオーバーロードすることができます。
これは Ruby ではできません。

[source,crystal]
----
include::./examples/example2.cr[]
----

それでは、 Crystal と Ruby で構文の異なる部分を一つ一つ説明していきます。

これらの違いを意識しながら読み進めていってください。

=== 型システム

はじめに Crystal の型システムについて簡単に説明しておきます。

Crystal の型には次のようなものがあります。

  * 通常の型
  ** `Int32` （整数）や `String` （文字列）、 `Nil` 、 `Bool` など
  * ジェネリックス
  ** `Array(Int32)` （要素の型が `Int32` の配列）
  ** `Array(String)` （要素の型が `String` の配列）
  ** `Hash(String, Int32)` （キーの型が `String` で値の型が `Int32` のハッシュ）
  * ユニオン
  ** `Int32 | String` （ `Int32` か `String` 型）
  ** `Int32?` （ `Int32 | Nil` の糖衣構文）
  * Proc
  ** `Int32 -> String` （引数に `Int32` を受け取って `String` を返す Proc）

こんなものがあるんだな、となんとなく覚えておいてください。

=== `typeof`

Ruby には無い構文として `typeof` というものが Crystal にはあります。

これは引数の式の結果の型を返す構文です。
引数の式はコンパイル時にのみ利用され、実行時には利用されないことに注意してください。

[source,crystal]
----
include::./examples/typeof.cr[]
----

=== リテラル

リテラル関連で Ruby と大きく異なるところは、次のものが挙げられます。

  * 数値リテラルの型指定
  * 空の配列と空のハッシュに対する型指定
  * タプルと名前付きタプル

逆に、これ以外は一部の例外を除いて Ruby と同じように書くことができます。

一部の例外：

  * いくつかの `%` 形式のリテラル（ `%s` や `%W` など）が存在しない。
  * ハッシュの `{foo: bar}` のような形式は名前付きタプルの構文となっている。
  * 正規表現の構文がPCREになっている。

==== 数値リテラルの型指定

Ruby の数値は基本的には `Integer` と `Float` だけですが、Crystal の数値はその大きさや符号の有無によって `Int32` 、 `Int64` 、 `UInt32` 、 `Float32` 、 `Float64` などが存在します。
`Int32` は 32bit の符号付き整数型で、 `UInt32` は 32bit の符号無し整数型、 `Float64` は 64bit の浮動小数点型です。
そして、数値リテラルの末尾に `i32` 、 `i64` 、 `f32` 、 `f64` などと付けることによって、値の型を指定できます。

もちろん数値リテラルの末尾に何も指定しないことも可能で、その場合は整数なら `Int32` 型、小数なら `Float64` 型になります。

[source,crystal]
----
include::./examples/number.cr[]
----

==== 空の配列と空のハッシュに対する型指定

空の配列は `[]` 、空のハッシュは `{}` のように書けますが、これだと要素やキーの型が分からないためコンパイルすることができません。
そこで Crystal では、空のリテラルのあとに `of 型` と続けることで型を指定します。
ハッシュの場合は `of キーの型 => 値の型` になります。

[source,crystal]
----
include::./examples/empty.cr[]
----

==== タプルと名前付きタプル

これは可変長引数、名前付き引数と関連の深い概念なので、そこで説明します。

=== 変数

変数名は小文字から始めなければならず、定数は大文字から始めねけらばいけません。
インスタンス変数は `@` から、クラス変数は `@@` から始めなければいけません。
これらは Ruby と同様です。

しかし Crystal にグローバル変数はありません。
代わりにクラス変数や定数を使ってください。

=== クラス・メソッド

クラス・メソッド関連で Ruby と大きく異なるところは、次のものが挙げられます。

  * メソッドの型指定・オーバーロード・ `previous_def`
  * 名前付き引数
  * 可変長引数の扱い
  * インスタンス変数の型
  * `struct`

また、 Crystal ではコンパイル時に全てのメソッドが定義されていなければいけません。
なので Ruby の `define_method` のようなことはできません。

==== メソッドの型指定・オーバーロード・ `previous_def`

メソッドの型指定・オーバーロードは前述しましたが、異なる引数の型の同名のメソッドを定義すると、呼び出し時に適切なものが選択される、という機能です。

また、このときに引数の型が一致するメソッドが見つからなかった場合、コンパイルエラーになります。

`previous_def` は反対に、一致するメソッドが複数見つかってしまった場合のための機能です。
この場合は、まず一番最後に定義されたものが呼び出されます。
そして、その中で `previous_def` を使うと、次に定義されたものが呼び出されるのです。

ちなみに、引数の型は指定しないこともできます。
その場合は任意の型を受け取ることになります。
ですが、実際に呼び出された引数が持っていないメソッドを呼び出していた場合は、コンパイルエラーになります。

[source,crystal]
----
include::./examples/previous_def.cr[tag=file]
----

==== 名前付き引数

名前付き引数とは、 Ruby ではキーワード引数と呼ばれるものです。

Crystal では、全ての引数を名前付き引数として呼び出すことができます。

他にも、名前付き引数として指定するための名前と、実際に引数として受け取る変数の名前を分けることができます。
これは、名前付き引数の名前として予約語を使いたいときに便利です。

[source,crystal]
----
include::./examples/named_arg.cr[tag=file]
----

==== 可変長引数

Ruby 同様、引数名の前に `*` を置くと可変長引数を受け取るものとして、 `**` を置くと名前付き引数の余った引数を受け取るものとしてマークされます。

しかし、 Ruby では可変長引数は配列を、キーワード引数の余りはハッシュを受け取りますが、 Crystal では可変長引数ではタプルに、名前付き引数の余りは名前付きタプルになります。

タプルは固定長で変更不可の配列のようなもので、それぞれの要素の型を保持できます。
また、名前付きタプルとタプル同様の特性を持ったキーがシンボルのハッシュのようなものです。

スプラット展開の際にも、これらを渡します。

[source,crystal]
----
include::./examples/vararg.cr[tag=file]
----

==== インスタンス変数の型

Crystal ではインスタンス変数・クラス変数の型がコンパイル時に決定できなければいけません。

`initialize` メソッドの中でインスタンス変数に代入している場合などは気を利かせて型を推論してくれます。
しかし、そうでない場合は型が分からずにコンパイルエラーになることがあります。
その場合は明示的にインスタンス変数の型を指定してください。

また、メソッドの引数名としてインスタンス変数を指定すると、メソッドの呼び出しと同時に、そのインスタンス変数に代入することができます。

// TODO: 例

==== `struct`

`class` とよく似たものとして `struct` があります。

`struct` も `class` とほぼ同等の機能を持っていますが、メモリ確保に違いがあります。
`class` で定義した型のインスタンスはヒープに置かれますが、 `struct` はスタックに置かれます。
このため `struct` の方が高速にインスタンスを作ることができます。

しかし、 `struct` は自分自身をインスタンス変数に持つことができないという制約があります。

=== `enum`

Crystal には `enum` があります。
これは連番の数値型に分かりやすい名前を付けたもので、さらにメソッドを定義することもできます。

また、 `@[Flags]` 属性を付けると、単なる連番ではなく値はビットフラグになります。

// TODO: 例

=== メソッド呼び出し

メソッド呼び出しの構文はほとんど Ruby と同じですが、一つだけ異なる点があります。

Crystal には一引数のブロックの省略記法というものがあります。
これは ブロックの最初の引数に対してメソッドを呼び出す場合に `&.メソッド名` のように書けるという構文です。
さらに、そこからメソッドチェインを始めることができるため、場合によっては非常に便利です。

[source,crystal]
----
include::./examples/call.cr[tag=file]
----

=== 条件分岐・繰り返し

条件分岐・繰り返しの構文は Ruby とほとんど同じです。
ただし `redo` はありません。

条件分岐の条件に変数が対象になっている場合、その変数の型がフィルターされます。

例えば、次のコードを考えてみましょう。

[source,crystal]
----
foo = rand > 0.5 ? "foo" : nil

# <1>
if foo
  # <2>
else
  # <3>
end
----
<1> `foo` の型は `String | Nil`
<2> この位置に来たら `foo` は確実に `String` 型
<3> この位置に来たら `foo` は確実に `Nil` 型

ということが分かると思います。

このように、条件分岐の条件によって、ブロック内で変数の型がいい感じに変化するのです。
